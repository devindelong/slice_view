/**
 * @file test_maybe_present.cpp
 * @copyright Copyright (c) 2025, Devin DeLong. All rights reserved.
 *
 * @license This code is distributed under the BSD 3-Clause License.
 *          See the LICENSE file for the full text of the license.
 *
 * @author Devin DeLong
 */

#include "dd/maybe_present.hpp"

#include "catch2/catch_test_macros.hpp"

#include <optional>
#include <tuple>
#include <vector>

// Each empty type should be unique and allow them to overlap memory when using
// [[no_unique_address]].
template <bool present>
struct multiple_maybe_present
{
  [[no_unique_address]] dd::maybe_present_t<present, int> int_one;
  [[no_unique_address]] dd::maybe_present_t<present, int> int_two;
};

TEST_CASE("maybe_present_t: empty type", "[sizeof]")
{
  // Empty type.
  REQUIRE(sizeof(dd::empty_type<>) == 1);

  // Empty variable.
  auto empty = dd::empty_type{};
  REQUIRE(sizeof(empty) == 1);
}

TEST_CASE("maybe_present_t: check conditional sizeof", "[sizeof]")
{
  // Check conditional is either empty or the size of the non-empty type.
  REQUIRE(sizeof(dd::maybe_present_t<true, int>) == sizeof(int));
  REQUIRE(sizeof(dd::maybe_present_t<false, int>) == 1);
}

TEST_CASE("maybe_present_t: empty type uniqueness", "[sizeof]")
{
  // Check that a unique type is generated by the lambda.
  REQUIRE(sizeof(multiple_maybe_present<false>) == 1);
  REQUIRE(sizeof(multiple_maybe_present<true>) == 2 * sizeof(int));
}

TEST_CASE("maybe_present_t: initializer list construction", "[constructor]")
{
  using vector = std::vector<int>;

  REQUIRE(
    std::constructible_from<
      dd::maybe_present_t<true, vector>, std::initializer_list<int>>);
  REQUIRE(
    std::constructible_from<
      dd::maybe_present_t<false, vector>, std::initializer_list<int>>);
}

TEST_CASE("maybe_present_t: in place construction", "[constructor]")
{
  using vector = std::vector<int>;
  using optional_vector = std::optional<vector>;

  REQUIRE(
    std::constructible_from<
      dd::maybe_present_t<true, optional_vector>, std::in_place_t,
      std::initializer_list<int>>);
  REQUIRE(
    std::constructible_from<
      dd::maybe_present_t<false, optional_vector>, std::in_place_t,
      std::initializer_list<int>>);
}

TEST_CASE("maybe_present_t: variadic constructor", "[constructor]")
{
  using container = std::tuple<int, int, int>;

  REQUIRE(std::constructible_from<dd::maybe_present_t<true, container>, int, int, int>);
  REQUIRE(std::constructible_from<dd::maybe_present_t<false, container>, int, int, int>);
}
